# 前端的未来 (WebAssembly)

为什么前端要学 Rust？除了工具链（SWC/Turbopack），更直接的应用就是 **WebAssembly (WASM)。**

WASM 允许你在浏览器里以接近原生代码的速度运行 Rust。这对于图像处理、复杂计算、游戏引擎来说是降维打击。

## 1. 神器：`wasm-bindgen`
在 Rust 里写 WASM 不需要你懂汇编。你只需要一个库：`wasm-bindgen`。它的作用就是充当“翻译官”，把 JS 的类型转成 Rust 的类型，反之亦然。

## 2. 实战：写一个“高性能”加法器
假设我们要在 Rust 里写一个函数，然后在 JS 里调用它。

### 第一步：Rust 代码 (`lib.rs`)
```rust
use wasm_bindgen::prelude::*;

// #[wasm_bindgen] 是一个宏，它告诉编译器：
// "把这个函数打包好，让 JS 能看懂！"
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

// 再来个更复杂的：JS 传名字，Rust 返回问候语
#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}! From Rust!", name)
}
```

### 第二步：编译
你不需要手写复杂的命令，只需要安装 `wasm-pack` 工具，然后运行：
```bash
wasm-pack build --target web
```
它会生成一个 `pkg` 文件夹，里面包含了 `.wasm` 文件和自动生成的 `.js` 胶水代码。

### 第三步：前端调用 (HTML/JS)
现在回到我们熟悉的领域：
```javascript
<script type="module">
  // 1. 导入生成的胶水代码
  import init, { add, greet } from './pkg/my_rust_project.js';

  async function run() {
    // 2. 初始化 WASM 模块 (加载 .wasm 文件)
    await init();

    // 3. 像调用普通 JS 函数一样调用 Rust！
    const sum = add(5, 7);
    console.log("Rust 算出来的结果:", sum); // 12

    const msg = greet("Frontend Dev");
    alert(msg); // "Hello, Frontend Dev! From Rust!"
  }

  run();
</script>
```
看见了吗？在 JS 侧，你根本感觉不到这是 Rust 写的。它就是一个普通的 `import`，普通的 `function`。但背后，是 Rust 的极致性能在支撑。

# 🎉毕业典礼
恭喜你！你已经读完了这本《前端开发者的 Rust 入门迷你书》。

回顾一下我们的旅程：
1. 变量：学会了 let mut 和 i32。
2. 内存：理解了所有权、借用 (&) 和深拷贝 (clone)。
3. 结构：掌握了 Struct 和超强的 Enum。
4. 逻辑：用 match 替代了 switch，用 Result 替代了 try-catch。
5. 融合：最后看了一眼 WASM 的魔法。

Rust 的学习曲线是“先苦后甜”。你会花很多时间和编译器（Borrow Checker）斗争，它会像一个严厉的老师，不停地打回你的作业。但请相信，**它是在救你。** 一旦代码编译通过，它通常就能完美运行，而且跑得飞快，绝不会有 `undefined is not a function` 这种低级错误。