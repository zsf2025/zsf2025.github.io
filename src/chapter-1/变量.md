# 变量--默认的“偏执”

作为前端开发者，我们习惯了这样的思维模式：
* 用`const`声明**不会**被重新赋值的变量。
* 用`let`声明**会**被修改的变量。

在 Rust 里，这个直觉会被稍微颠覆一下。

## 1. `let`的“谎言”
在 JavaScript 中，`let` 代表 "Let me change this later"（允许我稍后修改它）。 但在 Rust 中，`let` 默认居然是**不可变(Immutable)**的！

看看这段代码：
```rust
fn main() {
    let salary = 10000; // 定义薪水
    salary = 15000;     // 涨薪！
    println!("现在的薪水是: {}", salary);
}
```
如果你尝试运行这段代码，Rust 编译器会直接给你一个红色的报错。它会告诉你：**“你不能对不可变变量`salary`赋值两次。”**

## 2. `mut`--开启“修改权限”
如果你真的想让变量像 JS 的 `let` 一样可以修改，你需要显式地告诉编译器：**“嘿，这个变量我要改。”**

你需要加上 `mut` (mutable) 关键字：
```rust
fn main() {
    let mut salary = 10000; // 注意这里的 mut
    salary = 15000;         // ✅ 编译器：好的，这很合理。
    println!("现在的薪水是: {}", salary);
}
```

## 🧠 随堂小测验
为了确认你掌握了这个核心思维转换，请看下面这段简单的 Rust 代码（假设这是个计算器应用的一部分）：
```rust
fn main() {
    let result = 0;
    let factor = 2;
    
    result = 10 * factor;
    
    println!("结果是: {}", result);
}
```
**问题：** 这段代码会报错吗？如果是，**哪一行**会报错？你应该**添加**什么关键字来修复它？

## 答案
会报错，报错在第5行。你需要添加 `mut` 关键字来修复它：
```rust
fn main() {
    let mut result = 0;
    let factor = 2;
    
    result = 10 * factor;
    
    println!("结果是: {}", result);
}
```
加上 `mut` 关键字后，`result`就获得了“可变性”权限。这在Rust中是一个显式的决定，而在JS中是`let`默认赋予的。
